#### 浮动 ####
css允许浮动任何元素，从图像到段落再到列表，所有元素都可以浮动。
## <font color="#ff995" face="微软雅黑" size="3">**float**</font> ##

| 值 | `left、right、none、inherit` |
| ------ | ------ |
| 初始值 | none |
| 应用于 | <font color="#ff995" face="微软雅黑" size="3">**所有元素**</font> |
| 继承性 | 无 |
| 计算值 | 根据指定确定|

#### 浮动元素 ####
对于浮动元素有几点要记住。首先，它会以某种方式将浮动元素从文档的正常流中删除，不过它还是会影响布局。采用CSS的特有方式，浮动元素几乎"自成一派"，不过它们还是对文档的其余部分有影响。

这种影响源自于这样一个事实:一个元素浮动时，其他内容会"环绕"该元素。对于浮动图像来说，这种行为我们已经很熟悉了，不过要知道，元素浮动时也同样如此(例如，浮动一个段落)。

><font color="#ff995" face="微软雅黑" size="3">**可以注意到一些有意思的情况，首先，浮动元素周围的外边距不会合并。如果浮动一个有20像素外边距的图像，在这个图像周围将至少有20像素的空间。如果其他元素与此图像相邻(这表示水平相邻和垂直相邻)，而且这些元素也有外边距，那么这些外边距不会与浮动图像的外边距合并。**</font>

如果确实要浮动一个非替换元素，则必须为该元素声明一个width。否则，根据CSS规范，元素的宽度趋于0.因此，假设浏览器的最小width值是1个字符，那么浮动段落可能只有一个字符宽。

#### 不浮动 ####
除了left和right外，float属性还有一个值。float:none用于防止元素浮动。

这看上去有些啥，因为要让一个元素不浮动，最容易的办法就是不声明float，这样不就行了吗？确实如此，首先，float的默认值是none。换句话说，要得到正常的非浮动行为，必须有这个值；如果没有这个none值，所有元素都会以某种方式浮动。

其次，你可能想覆盖导入样式表中的某个样式。假设你在使用一个服务端样式表，这个样式表要让图像浮动。不过在某个特定的页面上，你不希望图像浮动。不必为此再编写一个全新的样式表，而只需在文档的嵌套样式表中增加img{float:none;}。不过，除了这种情况，确实很少有必要真正使用float:none。

#### 浮动的详细内幕 ####


><font color="#ff995" face="微软雅黑" size="3">深入讨论浮动的详细内容之前，首先要建立包含块的概念。这很重要。浮动元素的包含块是其最近的**块级祖先元素**。</font>


<font color="#ff995" face="微软雅黑" size="3">浮动元素会生成一个块级框，而不论这个元素本身是什么。因此，如果让一个链接浮动，即使该链接元素本身是行内元素，通常会生成一个行内框，但只要它是浮动的，就会生成一个块级框。它会像块级元素一样摆放和表现(例如,就好像是一个div元素)。对浮动元素声明display:block也不是不可能，不过没有必要这么做。</font>

有一系列特定规则控制着浮动元素的摆放，所以在介绍浮动元素的行为之前，先来讨论这些规则。这些规则与控制外边距和宽度计算的规则很相似，开始看起来都一样。规则如下:

1. 浮动元素的左(或右)外边界不能超出其包含块的左(或右)内边界。
2. 浮动元素的左(或右)外边界必须是源文档中之前出现的左浮动(或右浮动)元素的右(左)外边界，除非后出现的浮动元素的顶端在先出现浮动元素的底端下面。---这个规则的好处是，所有浮动内容都是可见的，因为你不必担心一个浮动元素与另一个浮动元素重叠。这使得浮动很安全。使用定位时情况则完全不同，定位很容易导致元素相互覆盖。
3. 左浮动元素的右外边界不会在其右边右浮动元素元素的左外边界的右边。一个右浮动元素的左外边界不会在其左边任何左浮动元素的右外边界的左边。---这个规则可以防止浮动元素相互重叠。
4. 一个浮动元素的顶端不能比其父元素的内顶端高。如果一个浮动元素在两个合并外边距之间，放置这个浮动元素时就好像在两个元素之间有一个块级父元素。
5. 浮动元素的顶端不能比之前所有浮动元素或块级元素的顶端更高。--浮动元素的顶端也不可能比之前出现的浮动元素的顶端更高。
6. 如果源文档中一个浮动元素之前出现另一个元素，浮动元素的顶端的顶端不能比包含该元素所生成框的任何行框的顶端更高。
7. 左(或右)浮动元素的左边(右边)有另一个浮动元素，前者的右外边界不能再其包含块的右(左)边界的右边(左边)。---也就是说，浮动元素不能超出其包含元素的边界，除非它太宽，本身都无法放下。
8. 浮动元素必须尽可能高地放置。
9. 左浮动元素必须向左尽可能远，右浮动元素则必须向右尽可能远。位置越高，就会向右或向左浮动得越远。

大多数浏览器的默认行为都是为br元素生成行内框，所以clear不能应用于br，除非改变其display值。

#### 清除 ####
## <font color="#ff995" face="微软雅黑" size="3">**clear**</font> ##

| 值 | `left、right、both、none、inherit` |
| ------ | ------ |
| 初始值 | none |
| 应用于 | <font color="#ff995" face="微软雅黑" size="3">**块级元素**</font> |
| 继承性 | 无 |
| 计算值 | 根据指定确定|

#### 定位 ####
定位的原理很简单。利用定位，可以准确地定义元素框相对于其<font color="#ff995" face="微软雅黑" size="3">**正常位置**</font>应该出现在哪里，或者相对于<font color="#ff995" face="微软雅黑" size="3">**父元素**</font>，<font color="#ff995" face="微软雅黑" size="3">**另一个元素设置浏览器窗口本身**</font>的位置。

#### 定位的类型 ####
## <font color="#ff995" face="微软雅黑" size="3">**position**</font> ##

| 值 | `static、relative、absolute、fixed、inherit` |
| ------ | ------ |
| 初始值 | static |
| 应用于 | <font color="#ff995" face="微软雅黑" size="3">**所有**</font> |
| 继承性 | 无 |
| 计算值 | 根据指定确定|

position值的含义如下:

#### static ####
元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。

#### relative ####
元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。

#### absolute ####
元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。

#### fixed ####
元素框的表现类似于将position设置为absolute，不过其包含块是视窗本身。

#### 包含块 ####
对于浮动元素，其包含块定义为最近的块级<font color="#ff995" face="微软雅黑" size="3">**祖先元素**</font>。

对于定位。CSS2.1定义了以下行为:


- "根元素"的包含块(也称为初始包含块)由用户代理建立。在HTML中，根元素就是html元素，不过有些浏览器会使用body作为根元素。在大多数浏览器中，初始包含块是一个视窗大小的矩形。



- 对于一个非根元素，如果其position值是relative或static，包含块则由**最近的块级框，表单元格或行内块**<font color="#ff995" face="微软雅黑" size="3">**祖先框**</font>的内容边界构成。



- 对于一个非根元素，如果其position值是absolute，包含块设置为最近的position不是static的<font color="#ff995" face="微软雅黑" size="3">**祖先元素(可以是任何类型)**</font>。这个过程如下:

     --如果这个祖先是块级元素，包含块设置为该元素的内边距边界；换句话说，就是由边框届定的区域。

     --如果这个祖先是行内元素，包含块则设置为该祖先元素的内容边界。在从左向右读的语言中，包含块的上边界和左边界是该祖先元素中第一个框内容区的上边界和左边界，包含块的下边界和右边界是最后一个框内容区的下边界和右边界。在从右向左读的语言中，包含块的右边界对应于第一个框的右内容边界，包含块的左边界则取自最后一个框的左内容边界。上下边界也是一样。

     --如果没有祖先，元素的包含块定义为<font color="#ff995" face="微软雅黑" size="3">**初始包含块**</font>。

这里有一点很重要:元素可以定位到其包含块的外面。这与浮动元素使用负外边距浮动到其父元素内容区外面很类似。这也说明，"包含块"一词实际上应该是"定位上下文"。

#### 限制宽度和高度 ####
如果有必要(或需要)，可以使用以下CSS2属性对元素的宽度加一些限制，我们把这些属性成为最小最大属性。通过使用min-width和min-height，可以为元素的内容区定义一个最小尺寸。

## <font color="#ff995" face="微软雅黑" size="3">**min-width、min-height**</font> ##

| 值 | `length、percentage、inherit` |
| ------ | ------ |
| 初始值 | 0 |
| 应用于 | <font color="#ff995" face="微软雅黑" size="3">**除了非替换行内元素和表元素以外的所有元素**</font> |
| 继承性 | 无 |
| 百分数 | 相对于包含块的宽度|
| 计算值 | 对于百分数，根据指定确定；对于长度值，则为绝对长度；否则，为none|

类似地，还可以使用属性max-width和max-height来限制元素的尺寸。

## <font color="#ff995" face="微软雅黑" size="3">**max-width、max-height**</font> ##

| 值 | `length、percentage、none、inherit` |
| ------ | ------ |
| 初始值 | none |
| 应用于 | <font color="#ff995" face="微软雅黑" size="3">**除了非替换行内元素和表元素以外的所有元素**</font> |
| 继承性 | 无 |
| 百分数 | 相对于包含块的高度|
| 计算值 | 对于百分数，根据指定确定；对于长度值，则为绝对长度；否则，为none|

#### 内容溢出和裁剪 ####
如果一个元素的内容对于元素大小来说过大，就有可能溢出元素本身。对于这种情况，有一些候选解决办法，CSS2允许你从中选择。它还允许定义一个裁剪区域，如果出了这个剪裁区域，这种溢出就会带来问题。

#### 溢出 ####
假设出于某种原因，一个元素固定为某个特定大小，但内容在元素中放不下。此时就可以利用overflow属性控制这种情况。


## <font color="#ff995" face="微软雅黑" size="3">**overflow**</font> ##

| 值 | `visible、hidden、scroll、auto、inherit` |
| ------ | ------ |
| 初始值 | visible |
| 应用于 | <font color="#ff995" face="微软雅黑" size="3">**块级元素和替换元素**</font> |
| 继承性 | 无 |
| 计算值 | 根据指定确定|

最后还有一个值overflow:auto。这允许用户代理来确定采用何种行为，不过都建议在必要时提供一个滚动机制。这可能是overflow的一个有用的用法，因为用户代理可以把它解释为"只在必要时提供滚动条"

#### 内容裁剪 ####
如果一个绝对定位元素的内容溢出其内容框，而且overflow设置为要求剪裁该内容，通过使用属性clip可以改变剪裁区域的形状。

默认值auto表示元素的内容不应剪裁。还可以相对于元素内容区定义一个剪裁形状。这不会改变内容区的形状，而只是改变将显示内容的区域形状。

## <font color="#ff995" face="微软雅黑" size="3">**clip**</font> ##

| 值 | `rect(top、right、bottom、left) auto inherit` |
| ------ | ------ |
| 初始值 | auto |
| 应用于 | <font color="#ff995" face="微软雅黑" size="3">**绝对定位元素(在CSS2中，clip应用于块级元素和替换元素)**</font> |
| 继承性 | 无 |
| 计算值 | 对于矩形，4个计算长度表示剪裁矩形区域的4个边，否则，根据指定确定|

这是利用形状值rect(top,right,bottom,left)实现的。可以如下指定剪裁区域内不做修改。

    clip:rect(0,auto,auto,0)

有一点极为重要，rect(...)的值不是边偏移，而是距元素<font color="#ff995" face="微软雅黑" size="3">**左上角**</font>的距离(从右向左读的语言中，则是与元素右上角的距离)。因此，如果一个剪裁矩形涵盖元素左上角20*20像素的一个正方形，可以定义如下:

    rect(0,20px,20px,0)

rect(....)只允许长度值和auto，如果设置为auto，这相当于将裁剪边界设置为适当的内容边界。

由于clip中的所有偏移都是距左上角的偏移，所以不允许有百分数，实际上不可能创建一个"中心"剪裁区域，除非你知道元素本身的大小。