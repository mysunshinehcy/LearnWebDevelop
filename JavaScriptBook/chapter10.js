//通过字面量定义正则表达式
var reg=/\bis\b/g;
//正则表达式直接量，匹配所有以字母"s"结尾的字符串

var pattern=/s$/;

//也可以用构造函数RegExp()定义一个与之等价的正则表达式

var pattern=new RegExp("s$");

//就像字符串和数字一样，程序中每个取值相同的原始类型直接量均表示相同的值，
//这是显而易见的。程序运行时每次遇到对象直接量(初始化表达式)诸如{}和[]都会创建
//新对象。比如:如果在循环体中写var a=[],则每次遍历都会创建一个新的空数组。

//正则表达式直接量则与此不同，ES3规范规定，一个正则表达式直接量
//会在执行到它时转换为一个RegExp对象，同一段代码所表示正则表达式直接量
//的每次运算都返回一个对象。ES5规范则做了相反的规定，同一
//段代码所表示的正则表达式直接量的每次运算都返回新对象。IE一直都是按照ES5
//规范实现的，多数最新版本的浏览器也开始遵循ES5，尽管标准并未全面广泛推行。

//这段代码Firefox3.6和Firefox 4+中的运行结果不一致
//在ES3规范中，用正则表达式创建的RegExp对象会共享一个实例，而在ES5中则是两个独立的实例
//而最新的Firefox4,chrome和Safari都遵循ES5标准，以至于在IE6-IE8都没有很好地遵循ES3
//标准，不过在这个问题上反而处理对了。很明显ES5的规范更符合开发者的期望。
function getRE(){
    var re=/[a-z]/;
    re.foo="bar";
    return re;
}

var reg=getRE(),re2=getRE();
console.log(reg===re2);//在Firefox3.6中返回true,在Firefox4+中返回false

reg.foo="baz";

console.log(re2.foo);//在Firefox3.6中返回"baz",在Firefox4+中返回"bar"

/*直接量字符*/
//字母和数字字符   自身
//  \o  NUL字符(\u0000)
//  \t  制表符(\u0009)
//  \n  换行符(\u000A)
//  \v  垂直制表符(u\000B)
//  \f  换页符(\u000C)
//  \r  回车符(\u000D)
//  \xnn 由十六进制数nn制定的拉丁字符，例如,\x0A等价于\n
//  \uxxxx 由十六进制数xxxx指定的Unicode字符，例如\u0009等价于\t
//  \cX  控制字符^X,例如,\cJ等价于换行符\n

//在正则表达式中，许多标点符号具有特殊含义，它们是:   ^ $ . * + ? = ! : | \ / ( ) [ ] { }


//正则表达式的字符类
//   [...]       方括号内的任意字符
//   [^...]      不在方括号内的任意字符
//   .           除换行符和其他Unicode行终止符之外的任意字符
//   \w          任何ASCII字符组成的单词，等价于[a-zA-Z0-9]
//   \W          任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]
//   \s          任何Unicode空白符
//   \S          任何非Unicode空白符的字符，注意\w和\S不同
//   \d          任何ASCII数字，等价于[0-9]
//   \D          除了ASCII数字之外的任何字符，等价于[^0-9]
//   [\b]        退格直接量(特例)



/*正则表达式的重复字符语法
*/
//{n,m}匹配前一项至少n次，但不能超过m次
//{n,}匹配前一项n次或者更多次
//{n}匹配前一项n次
//?匹配前一项0次或1次，也就是说前一项是可选的，等价于{0,1}
//+匹配前一项1次或者多次,等价于{1,}
//*匹配前一项0次或多次，等价于{0,}

//一些实例
/\d{2,4}/       //匹配2-4个数字
/\w{3}\d?/      //精确匹配三个单词和一个可选的数字
/\s+java\s+/    //匹配前后带有一个或多个空格的字符串"java"
/[^(]*/         //匹配一个或多个非左括号的字符